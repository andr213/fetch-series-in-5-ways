# Последовательный fetch и 5 способов решения
### или иной взгляд на техничку JavaScript инженера

####

![](/assets/main-picture.gif)

#### Вступление

На технических собеседованиях, помимо проверки теоретических знаний, принято задавать задачки, чтоб оценить уровень 
практических знаний кандидата, его способность писать код, способность мыслить логически и алгоритмически. Часто в этот 
список входят алгоритмические задачи. Все уже к ним привыкли и при подготовке, в первую очередь, смотрят именно на них. 
Список там большой, но основное, что чаще всего встречается, выглядит примерно так: 

- факториал
- числа Фибоначчи
- уникальность элементов массива
- проверка на сбалансированность скобок внутри текста
- сортировки (mergeSort, insertionSort, bubbleSort, quickSort)
- деревья (обход в глубину / обход в ширину / нахождение кратчайшего пути между узлами)

За последние два года, проведя порядка 70 собеседований по JavaScript, постепенно пришел к мнению, что они не всегда 
или не полностью отражают действительность, так как именно их и ожидает кандидат, именно к ним он и подготовился лучше 
всего (а если не подготовился, то сам виноват).

Поэтому хотелось задания, которое удовлетворяло бы следующим критериям:

- легкость для понимания кандидатом
- приближено к реальной задаче
- способность отразить уровень практических знаний кандидата
- наличие нескольких решений
- не занимало бы много времени на решение

И самая, на мой взгляд, простая практическая задача оказалась в числе претендентов совершенно случайно. 

Задача звучала примерно следующим образом:

> Предположим, нам надо сделать несколько последовательных запросов к серверу со следующими условиями:
>	1. количество запросов заранее неизвестно
>	2. результат выполнения каждого запроса должен передаваться в качестве параметров в следующий
>	3. без использования сторонних библиотек
>
> Схематично это выглядело бы примерно так:
*fetch(url1) => fetch(url2, resultsUrl1) => fetch(url3, resultsUrl2)*
>
> или что-то вроде
> compose(res2 => fetch(url3, res2), res1 => fetch(url2, res1), () => fetch(url1))  
> 
> как бы мы могли решить эту задачу?

И по прошествии нескольких десятков собеседований был составлен примерный список ответов, которые сходу предлагали 
кандидаты (отсортированный по частоте их использования):

- генераторы
- async/await
- рекурсия

Потом мы переходили к решению задачи, предложенным кандидатом методом; в некоторых случаях быстро понимали, что этот 
метод чем-то нас не устраивает; предлагались другие методы; и решение простой задачи часто растягивалось во времени и строчках 
кода.

Тогда было принято решение предварительно решить задачу всеми способами, чтоб иметь возможность сравнить их между собой 
объективнее. Именно этот опыт предоставил бы возможность более предметно дискутировать. Ведь всегда оставалась 
вероятность, что есть более лаконичное и красивое решение среди предложенных кандидатами, которое просто отметалось, 
основываясь на субъективном мнении.

Так как список решений кандидатов не казался исчерпывающим, было добавлено еще решение задачи с помощью асинхронных 
генераторов и обычного метода ``reduce``, являющегося прототипом ``Array``. Тем самым общий список решений дополнился 
двумя пунктами:

- асинхронные генераторы
- метод ``reduce``

И так, для простоты возьмем фейковую fetch функцию, которая будет имитировать запросы к серверу:

````
function fakeFetch (url, params='-') {
	// этот вывод в консоль покажет порядок вызовов с их входящими параметрами
	console.log(`fakeFetch to: ${url} with params: ${params}`);
	return new Promise(resolve => {
		setTimeout(() => resolve(`${url} is DONE`), 1000);
	})
};
````

Cписок адресов, для простоты, ограничим тремя элементами:
````
const urls = ['url1', 'url2', 'url3'];
````

Но наше решение должно не зависеть от их количества (смотрим условие 1), т.е цепочки вида ``then().then().then()`` и 
``await; await; await;`` заранее отбраковываются.

Для наглядности, результат будем выбрасывать в callback. Тогда вызов функции во всех случаях будет выглядеть одинаково:

``fetchSeries(result => console.log(`result: ${result}`))``

Я не смог найти универсального способа оценки, поэтому оценивать будем по количеству строк. Разумеется, в реальных 
условиях этот способ оценки не может применяться, но для нашего случая он вполне подходит, позволяя отсечь слишком 
громоздкие решения. Для этого будем придерживаться одинаковых правил переноса строк, 
чейнинг методов и блоков, чтобы в результате получить наиболее объективные оценки.

#### Генераторы
Ни один из кандидатов, выбравший этот способ для решения задачи первоначально, не смог довести решение до конца. 
Изначально, по непонятным причинам, многим оно казалось самым простым и целесообразным, но начиная идти этим путем, 
все быстро сдавались: 
 
````
function generatorWay(callback) {
	function* generateSequence() {
		let results;
		for (let url of urls) {
			results = yield fakeFetch(urls, results);
		}
		return results;
	}
	function execute(generator, yieldValue) {
		let next = generator.next(yieldValue);
		if (!next.done) {  
			return next.value
				.then(result => execute(generator, result));
		}
		callback(next.value);
	}
	execute(generateSequence())
}
````
[попробовать можно тут](https://jsbin.com/dasozus/edit?js,console)
 
Общий принцип такой:
- генератор generateSequence `yield'ит` не просто значения, а промисы.
- есть специальная функция `execute(generator)`, которая запускает генератор последовательными вызовами  `next`, 
получает из него промисы - один за другим, и, когда очередной промис выполнится, возвращает его результат в генератор 
следующим `next`.
- последнее значение генератора `execute` уже обрабатывает как окончательный результат, вызывая callback.

#### Асинхронные генераторы
Чтобы избежать рекурсии в предыдущем способе, можно воспользоваться асинхронным генератором и итерировать его 
циклом ``while``:

````
async function asyncGeneratorWay(callback) {
	async function* generateSequence() {
		let results;
		for (let url of urls) {
			results = yield await fakeFetch(url, results);
		}
		return results;
	}
	let generator = generateSequence();
	let result;
	while (!result || !result.done) {
		result = await generator.next(result && result.value);
	}
	callback(result.value);
}
````
[попробовать можно тут](https://jsbin.com/fagazu/edit?js,console)

Так мы экономим несколько строк и получаем более читабельный код (хотя этот аргумент довольно спорный).

Перебирать же с помощью ``for await of`` не выйдет, потому что это нарушит дополнительное условие 2.

#### Асинхронная функция (async/await)
Второй по популярности способ. Он довольно прост, нагляден и краток. Единственным ограничением может быть невозможность 
добавления ключевого слова async перед внешней функцией, так как это обязательное условие при использовании ключевого 
слова ``await``, что не всегда представляется возможным.

````
async function asyncAwaitWay(callback) {
	let results;
	for (const url of urls) {  
		results = await fakeFetch(url, results);
	}
	callback(result);
}
````

[попробовать можно тут](https://jsbin.com/yimitim/edit?js,console)

Тут мы просто в цикле вызываем каждый ``fakeFetch`` и ждем его выполнения с помощью ``await``;

#### Recursion
По сути, это повторение метода reduce (о котором речь пойдет немного дальше), только перебор осуществляется рекурсивным 
вызовом функции ``recursion`` самой себя. Но количество кода получается вдвое больше. Выглядит немного неуклюже, будто 
создаем рекурсию ради рекурсии:

````
function recursionWay(callback) {  
	const recursion = (arr = [], promise = Promise.resolve()) => {
		if (!arr.length) { 
			return promise;
		}
		const [url, ...restUrls] = arr;
		return promise
			.then(res => recursion(restUrls, fakeFetch(url, res)));
	}
	recursion(urls)
		.then(result => callback(result));
}
````
[попробовать можно тут](https://jsbin.com/qotecig/edit?js,console)

На самом деле можно было использовать метод shift вместо деструктуризации, но количество строк от этого не меняется. 
А деструктуризация выглядит немного читабельнее для нашего примера.

Promise.resolve(), в качестве значения по-умолчанию, используем для первой итерации, когда никакого промиса у нас еще 
нет, чтоб избежать постоянных проверок.

#### reduce
И наконец, последний метод решения. Разумеется, в беседе мы часто приходили к этому решению, но изначально ни одним 
кандидатом он не был озвучен как возможное решение задачи. 

````
function reduceWay(callback) {
	urls.reduce((accum, item) => {
		return accum
			.then(res => fakeFetch(item, res))
	}, Promise.resolve())
		.then(result => callback(result));
}
````
[попробовать можно тут](https://jsbin.com/jogacok/edit?js,console)

Тут все просто: 
	- итерируемся по массиву c помощью метода ``reduce`` массива
	- по цепочке запускаем следующий fakeFetch из метода then;
	- так же как и в предыдущем способе, Promise.resolve(), в качестве значения по-умолчанию, используем для первой 
	итерации, когда никакого обещания(Promise) у нас еще нет, чтоб избежать постоянных проверок. Это выглядит 
	равноценно такой записи:

````
function reduceWay(callback) {
	urls.reduce((accum, item) => {
		if (!accum) {
			return fakeFetch(item);
		}
		return accum
			.then(res => fakeFetch(item, res));
	})
		.then(result => callback(result));
}
````

при этом получаем на 3 строки кода меньше

#### Выводы

Получилась вот такая таблица сравнений. Это все, что можно выдать за объективность в рамках нашего эксперимента:

| способ | кол. строк | разница |
|--|--|--|
|reduce|5|1|
|async/await|5|1|
|recursion|10|x2|
|асинхронные генераторы|13|x2.6|
|генераторы|16|x3.2|

Исходя из данных таблицы сравнения видно, что у нас есть два явных победителя. Это асинхронная функция и обычный метод 
``reduce``. Выглядят они достаточно коротко и выразительно. Отличие лишь в стиле написания. ``reduce`` представляет
собой функциональный стиль, а асинхронная функция - императивный.
У каждого подхода найдутся свои сторонники и противники, но всегда представится случай, где какой-либо из подходов будет 
более подходящим.
 
Разумеется, в реальных условиях код с использованием ``reduce`` будет еще немного короче (за счет форматирования). И 
может выглядеть, например, так:

````
const reduceWay = () => urls.reduce(
	(acc, item) => acc.then(res => fakeFetch(item, res)),  
	Promise.resolve(),
)}
````

Способ с использование асинхронной функции, скорее всего, останется без изменений.

#### Послесловие
Простая, казалось бы, практическая задача ставила в тупик многих кандидатов, что и послужило причиной выбора ее для 
дальнейших собеседований.

Для сильных кандидатов была возможность проверить знание и умение работы с генераторами, для средних - с рекурсиями. 
Для евангелистов async/await - показать, что есть другие способы, не уступающие по объему кода и наглядности. 
Новичков всегда можно было определить по неумению работы с ``reduce`` и/или боязни использования рекурсий.

Это не полноценная задача для оценки уровня кандидата, но начало для беседы, в результате которой рождается истина... 
но это не точно.

#### *полезные ссылки*

[Генераторы](https://learn.javascript.ru/generator)

[Асинхронные генераторы](https://learn.javascript.ru/async-iterators-generators#asinhronnye-generatory)

[Массив: перебирающий метод reduce](https://learn.javascript.ru/array-iteration#reduce-reduceright)

[Рекурсия](https://learn.javascript.ru/recursion)

[Async/await](https://learn.javascript.ru/async-await)

[Промисы](https://learn.javascript.ru/promise-basics)

[Цепочка промисов](https://learn.javascript.ru/promise-chaining)

[Статья на Medium](https://medium.com/@yaandrey/%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-fetch-%D0%B8-5-%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%BE%D0%B2-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F-f0ce8e5d791a)
